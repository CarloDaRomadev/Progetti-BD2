//Cambio dei tipi di dato per adatatamento al dbms (postgresSql)
nuovi:
	tipot = create type tipot as enum('composta', 'semplice')
	tipoW = create type tipoW as enum('pubblica', 'privata')
dataOra -> dateTime
data -> date
float -> reale
float > 0 -> create domain floatgz as float
				check value > 0 

float >= 0 -> create domain floatgez as float
				check value >= 0 

int -> integer
int > 0 -> create domain intgz as integer
				check value > 0 

int >= 0 -> create domain intgez as integer
				check value >= 0 

stringa -> varchar
bool -> boolean
tipoDurata -> interval
cc -> create domain identificativo as varchar
					check value is like %regex%$)£/(=)

maddr -> create domain identificativo as varchar
					check value is like %regex%$)£/(=)

num -> create domain identificativo as varchar
					check value is like %regex%$)£/(=)

addr -> create type addr as (via: varchar, civico: intgz)

identificativo -> create domain identificativo as varchar
					check value is like %regex%$)£/(=)

operazioni di classe:
	prezzo(carrello: intgz): Realegez
		select sum(prezzolocal(p.id,ca_po.quantità))
		from Carrello as c
		join ca_po on c.id = ca_po.carrello
		join Post as p on p.id = ca_po.post
		where c.id = carrello

	(aux)prezzolocal(p:intgz,q:intgz)
		Q = select t.prezzo
		from Post as po
		join Tariffa as t on t.post = t.id
		where po.id = p and 

		if Q is not NULL{
			return Q.prezzo + (select po.prezzo
							   from Post as po
							   where po.id = p
								)
		}
		else
		Q = select t.prezzo
		from Post as po
		join Tariffa as t on t.post = t.id
		join Range as r on r.tariffa = Tariffa.id
		where po.id = p and r.min < q < r.max

		return Q.prezzo + (select po.prezzo
							   from Post as po
							   where po.id = p
								)

	fine(buac: intgz): date
		Q = select ba.datai,b.durata
		from BuonoAcquistato as ba
		join Buono as b on ba.buono = b.id
		where ba.id = buac

	return (Q.datai + Q.durata)

[T.Utente.IscrizionePrimaDiAcquisti] à
inserimento in acquisto
is valid = not exist (select *
					  from Utente as u
					  join Carello as c on u.id = c.utente
					  join Acquisto as a on c.id = a.carrello
					  where a.tempo < u.ir
					 ) 
if is valid == TRUE{
	continue
}
else{
	rollback
}

[T.Utente.Buono_dataiMaggioreIR]
[T.Buono.inizioPrimaDiFine]
[T.Range_piùCompriMenoSpendi]
[T.Range.nonIntersecare]
[T.NonEsistonoDueTariffePerLoStessoPaese]
[T.Range_se_solo_se_tariffaComposta]
[T.costo_se_solo_se_tariffaSemplice]

vincoli aggiunti:
[V.Range_se_solo_se_tariffaComposta]
ALL t Tariffa(t) and Composta(t) <-> Exist Range(r) and co_ra(c,r)

[V.costo_se_solo_se_tariffaSemplice]
ALL t Tariffa(t) and Semplice(t) <-> Exist c Costo(t,c)

i vincoli omessissi sono stati implementati tramite semplici check.

paesePiùCompratore(i:date, f:date): Varchar[1..*]
conveniente(c: varchar, t: varchar[1..*]): (varchar, realegez) [0..*]
tendenza(): code[0..*]
